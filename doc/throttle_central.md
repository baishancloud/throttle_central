## 中心节点模块实现

### context

每启动一个中心节点服务时创建一个变量'context'，类型为字典，为各个线程共享
的上下文，其中包含一些统计信息（如'consumption_sum')，和上层逻辑提供的回调
函数（如'list_limits')，还包括一些配置（如'ip', 'port')。

### 用户限制的设置值获取

通过回调函数'list_limits'获取，该函数返回一个列表，每项对应一个用户的设置，
设置中包括每秒钟该用户可以使用每种资源的数量。

### 用户可使用资源数量的积累

对用户使用资源的限制不会严格按照每秒都只能最多使用所设置的数量的资源，只会
保证在一段时间内每秒使用资源数量的平均值不超过所设置的数值。

当某一秒用户使用某种资源的数量没有达到所设置的值时，未用完的那部分会被累积
起来，然后下一秒可以使用的资源就可以超过所设置的限制值。累积值是有上限的，
不能无限的累积。

### 资源桶

为了实现上面提到的资源累积，可以为每个用户对应每种资源都设置一个资源桶，每秒
向对应资源桶中加入一定数量的资源，该数量即为所设置的限制值，桶中资源的数量即
为当前已经累积的数量，由于桶是有大小的，所以桶的大小对应于可以累积资源数量的
上限。

当中心节点接收到端节点发送的用户资源消耗数量信息时，从对应资源桶中移去对应数量
的资源。由于端节点发送的是已经消耗的资源数量，必须要从资源桶中移除对应数量的
资源，所以资源桶中资源数量可以为负数，且没有下限。

通过判断资源桶中资源的数量是否大于0，就可以确定对应用户下一秒是否还可以使用
该项资源，以及还可以使用的资源数量。

得到某个用户某种资源还可以使用的数量之后，还需要将这个数量拆分成多份，分配到
不同端节点，端节点根据所分配到的数量限制对应节点上对应用户对资源的使用。

### 可使用资源数量在不同端节点上的分配

由于资源的消耗发生在端节点上，对资源使用的限制也是通过端节点拒绝处理请求来实现
的。用户的请求是随机分散在所有端节点上的，在分配资源数量到端节点时，无法预测
未来时间某个用户请求的资源在端节点的实际分布比例，因此无法得到一个完全正确的分配
比例。

为了得到一个近似合理的分配比例，我们使用最近一段时间用户在各个端节点消耗
对应资源的比例作为分配比例，但是也不能仅仅只考虑实际消耗的资源，还要将拒绝的次数
考虑在内，应为如果某个节点上被拒绝的次数很多，说明落在那个节点上的请求的个数也
很多。

### distribution结构定义

该结构体保存每个service中，不同用户消耗的不同资源的数量在不同端节点上的分布
情况。这些信息用于计算可使用资源数量在不同端节点上的分配比例。 其中
'consumption'项为对应端节点上对应用户消耗对应资源的数量，而'rejection'
项为对应端节点上对应用户因为对应资源不足而被拒绝的次数。

``` python
distribution = {
    'front': {
        'user_1':  {
            'traffic_up': {
                  'node_id_1': {
                      'slot_number': 1508985221,
                      'consumption': 432434,
                      'rejection': 444,
                  },
                  'node_id_2': {
                      'slot_number': 1508985221,
                      'consumption': 334345,
                      'rejection': 222,
                  },
                  ....
            },
            'traffic_down': {
            },
            'database_read': {
            },
            'database_write': {
            },
        },
        'user_2': {
        },
        ....
    }
}
```

### consumption_sum/rejection_sum

这两个变量为字典类型，结构与'consumption'和'rejection'相同，保存
的是每个slot中，用户在所有端节点上使用每种资源的数量，或因某种资源
不足而被拒绝的次数。

### 中心节点模块组成

中心节点包括三种线程：assign线程，消息处理线程，通信线程。

#### assign线程

assign线程在每秒中间时刻，将资源桶中资源数量按比例分配给不同端节点，
分配结果为未来若干slot，在每个slot中各个端节点上，某个用户可以使用
某种资源的数量。该结果会被保存下来，在端节点汇报信息时返回给对应端
节点。

assign线程为每个service一个，因此不同service可以使用不同的资源控制
策略，或不同的资源分配方式。

assign线程通过调用service模块提供的assign()接口完成相关功能。

#### 通信线程

通信线程接收端节点发送的汇报信息，该信息每个端节点每秒发送一次，信息
的内容为端节点构建出的上一秒对应的consumption和rejection结构字典，即
上一秒对应的slot中，各个用户在那个端节点上使用的各种资源的数量，和被
拒绝的次数。

在接收到汇报信息后将信息放入消息队列中，然后调用各个service模块提供的
get_quota()接口，把该接口返回的资源配额信息返回给端节点。

#### 消息处理线程

消息处理线程只有一个，循环从消息队列中取出一个端节点汇报的消息，根据
消息的内容更新distribution，consumption_sum，rejection_sum的内容。
对消息中包含的每个service，调用对应service模块提供的consume()接口。

### service模块

每个service提供一个独立的模块，该模块提供三个接口：
consume()接口，get_quota()接口，assign()接口。

#### service模块的consume()接口

consume()接口函数完成资源消耗的操作，传入的参数为某个slot中，各个用户消
耗各种资源的数量。

#### service模块的get_quota()接口

get_quota()接口函数用于获取quota，传入的参数为信息汇报时刻对应的
slot_number和端节点的id，该函数应该返回对应端节点该service的quota。

#### service模块的assign()接口

assign()接口函数由框架代码每秒调用一次，该函数应当计算出未来若干个slot中，
在不同端节点上每个用户可以使用各种资源的数量，计算得到的值会被get_quota
接口返回给对应端节点。

### 端节点汇报的消息示例

``` python
{
    "node_id": "00163e0069ec",
    "slot_number": 1515118666,
    "consumption": {
        "front": {
            "user_foo": {
                "traffic_up": 11534593,
                "database_read": 3,
                "database_write": 3
            }
        }
    },
    "rejection": {
        "front": {
            "user_bar": {
                "traffic_up": 10,
            },
        }
    }
}
```

### 中心节点返回给端节点的quota示例

```
{
    "front": {
        "1515120413": {
            "user_foo": {
                "traffic_down": 20971520.0,
                "database_read": 51200.0,
                "database_write": 51200.0,
                "traffic_up": 1048576000.0
            }
        }
    }
}
```
